#!/usr/bin/env bash

SCRIPTDIR="$(unset CDPATH && cd "`dirname "$0"`" && pwd)"
echo "SCRIPTDIR=${SCRIPTDIR}"
GITHUB_ACTION_PATH="${GITHUB_ACTION_PATH:-${SCRIPTDIR}}"
echo "GITHUB_ACTION_PATH=${GITHUB_ACTION_PATH}"


# Try to programmatically fetch the default branch. Go by the first remote HEAD found, otherwise
# default to `master`. $1 The variable to store the result
function get_default_branchmf {
  local __result=$1
  local __remotes=$(git remote)
  if [[ -n $__remotes ]]; then
    for __remote in $__remotes; do
      local __default_branch_ref=$(git symbolic-ref --quiet refs/remotes/${__remote}/HEAD || true)
      local __default_branch=${__default_branch_ref#refs/remotes/${__remote}/}
      if [[ -n ${__default_branch} ]]; then
        break
      fi
    done
  fi

  eval "${__result}=${__default_branch:-main}"
}


setVersionTagSimple() {
  local __version="$1"
  if [ -z "${__version}" ]; then
    echo "Error tag is blank"
    exit 1
  fi
  
  #  git tag -fa "${MAJOR_TAG}" -m 'Update major version tag'
  git tag -f $__version
  # If we have a remote, we push there
  local __remotes=$(git remote)
  if [[ -n $__remotes ]]; then
    for __remote in $__remotes; do
      git push $__remote $__version --force > /dev/null
      if [ $? -eq 0 ]; then
        echo "$__version pushed to $__remote"
      else
        echo "Error pushing the tag $__version to $__remote"
        exit 1
      fi
    done
  else
    echo "$__version"
  fi
}

getNextTagVersion() {
  SCOPE="$1"
  if [ -z "$SCOPE" ]; then
    SCOPE="auto"
  fi
  # We get the next version, without tagging
  nextversion="$( source "${GITHUB_ACTION_PATH}/semtag" final -fos "$SCOPE" )"
  echo "$nextversion"
}

setNextTagVersion() {
  nextversion="$1"
  # We update the tag with the new version
  output="$( source "${GITHUB_ACTION_PATH}/semtag" final -v "$nextversion" )"
  rt=$? ; echo "${output}" ; [[ $rt -eq 0 ]] || exit $rt
}

replaceNextTagVersion() {
  # We replace the placeholder in the source with the new version
  replace="s/^PROG_VERSION=\"[^\"]*\"/PROG_VERSION=\"$nextversion\"/g"
  sed -i.bak "$replace" semtag
  # We replace the version in the README file with the new version
  replace="s/^\[Version: [^[]*]/[Version: $nextversion]/g"
  sed -i.bak "$replace" README.md
  # We remove the backup README.md generated by the sed command
  rm semtag.bak
  rm README.md.bak

  # We add both changed files
  if ! git add semtag README.md ; then
    echo "Error adding modified files with new version"
    exit 1
  fi

  if ! git commit -m "Update readme and info to $nextversion" ; then
    echo "Error committing modified files with new version"
    exit 1
  fi

  if ! git push ; then
    echo "Error pushing modified files with new version"
    exit 1
  fi
}


